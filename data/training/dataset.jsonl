{"instruction": "What is the capital of France?", "input": "", "output": "The capital of France is Paris. It's located in the north-central part of the country along the Seine River and has been the capital since the 10th century."}
{"instruction": "Explain how a binary search algorithm works", "input": "", "output": "Binary search is an efficient algorithm for finding an item in a sorted array.\n\n**How it works:**\n1. Start with the middle element of the array\n2. If the target equals the middle element, return its position\n3. If the target is less than the middle, search the left half\n4. If the target is greater than the middle, search the right half\n5. Repeat until found or the search space is empty\n\n**Time complexity:** O(log n) - each step halves the search space\n**Space complexity:** O(1) for iterative, O(log n) for recursive\n\n**Example in Python:**\n```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n```"}
{"instruction": "How do I create a virtual environment in Python?", "input": "", "output": "To create a Python virtual environment:\n\n**Using venv (built-in, Python 3.3+):**\n```bash\n# Create the environment\npython -m venv myenv\n\n# Activate it\n# Windows:\nmyenv\\Scripts\\activate\n# Linux/Mac:\nsource myenv/bin/activate\n\n# Install packages\npip install package-name\n\n# Deactivate when done\ndeactivate\n```\n\n**Using conda:**\n```bash\nconda create -n myenv python=3.11\nconda activate myenv\nconda deactivate\n```\n\nVirtual environments isolate project dependencies, preventing conflicts between different projects."}
{"instruction": "What are the main differences between SQL and NoSQL databases?", "input": "", "output": "**SQL Databases (Relational):**\n- Structured data in tables with rows and columns\n- Fixed schema defined upfront\n- ACID compliance (Atomicity, Consistency, Isolation, Durability)\n- Use SQL for queries\n- Vertical scaling (more powerful hardware)\n- Examples: PostgreSQL, MySQL, SQLite, SQL Server\n\n**NoSQL Databases (Non-relational):**\n- Flexible data models (document, key-value, column, graph)\n- Dynamic schema\n- BASE properties (Basically Available, Soft state, Eventually consistent)\n- Various query languages or APIs\n- Horizontal scaling (more machines)\n- Examples: MongoDB, Redis, Cassandra, Neo4j\n\n**When to use SQL:** Complex queries, transactions, data integrity critical, structured data\n\n**When to use NoSQL:** Rapid development, massive scale, unstructured/semi-structured data, flexible schema needs"}
{"instruction": "Write a function to reverse a linked list in Python", "input": "", "output": "Here's how to reverse a singly linked list:\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_linked_list(head: ListNode) -> ListNode:\n    \"\"\"Reverse a linked list iteratively.\"\"\"\n    prev = None\n    current = head\n    \n    while current:\n        next_node = current.next  # Save next\n        current.next = prev       # Reverse pointer\n        prev = current            # Move prev forward\n        current = next_node       # Move current forward\n    \n    return prev\n\n# Recursive version\ndef reverse_recursive(head: ListNode) -> ListNode:\n    if not head or not head.next:\n        return head\n    \n    new_head = reverse_recursive(head.next)\n    head.next.next = head\n    head.next = None\n    \n    return new_head\n```\n\n**Time complexity:** O(n)\n**Space complexity:** O(1) iterative, O(n) recursive"}
{"instruction": "Explain the difference between HTTP GET and POST requests", "input": "", "output": "**GET Request:**\n- Retrieves data from the server\n- Parameters sent in URL query string\n- Cached by browsers\n- Bookmarkable\n- Visible in browser history\n- Limited data size (~2KB-8KB depending on browser)\n- Idempotent (same request = same result)\n- Should not modify server state\n\n**POST Request:**\n- Sends data to the server\n- Parameters sent in request body\n- Not cached by default\n- Not bookmarkable\n- Not stored in browser history\n- No size limitations\n- Not idempotent\n- Used for creating/updating resources\n\n**Examples:**\n```\nGET /users?id=123 HTTP/1.1\n\nPOST /users HTTP/1.1\nContent-Type: application/json\n\n{\"name\": \"John\", \"email\": \"john@example.com\"}\n```\n\n**Use GET for:** Fetching data, search queries, filtering\n**Use POST for:** Form submissions, file uploads, creating records, sensitive data"}
{"instruction": "How does garbage collection work in programming languages?", "input": "", "output": "Garbage collection (GC) automatically manages memory by reclaiming objects no longer in use.\n\n**Common Algorithms:**\n\n**1. Reference Counting:**\n- Track reference count for each object\n- Free when count reaches zero\n- Problem: Cannot handle circular references\n- Used by: Python (with cycle detector), Objective-C\n\n**2. Mark and Sweep:**\n- Mark phase: Traverse from root objects, mark reachable objects\n- Sweep phase: Free unmarked objects\n- Handles circular references\n- Used by: JavaScript, early Java\n\n**3. Generational GC:**\n- Objects divided into generations (young, old)\n- Young objects collected frequently (most die young)\n- Old objects collected less often\n- Used by: Python, Java, .NET, Go\n\n**4. Concurrent/Incremental GC:**\n- Runs alongside application\n- Reduces pause times\n- More complex implementation\n\n**Tradeoffs:**\n- Convenience vs. control\n- Pause times vs. throughput\n- Memory overhead for tracking"}
{"instruction": "What is the difference between concurrency and parallelism?", "input": "", "output": "**Concurrency:**\n- Dealing with multiple tasks at once (structure)\n- Tasks may not run simultaneously\n- Single core can achieve concurrency via time-slicing\n- About managing multiple tasks\n- Example: A chef preparing multiple dishes, switching between them\n\n**Parallelism:**\n- Executing multiple tasks simultaneously (execution)\n- Requires multiple cores/processors\n- Subset of concurrency\n- About doing multiple things at once\n- Example: Multiple chefs each preparing a different dish\n\n**In Practice:**\n\n```python\n# Concurrency (asyncio)\nasync def fetch_data():\n    await http_request()  # Switch to other tasks while waiting\n\n# Parallelism (multiprocessing)\nfrom multiprocessing import Pool\nwith Pool(4) as p:\n    results = p.map(cpu_intensive_task, data)\n```\n\n**When to use:**\n- **Concurrency:** I/O-bound tasks (network, disk, database)\n- **Parallelism:** CPU-bound tasks (calculations, data processing)\n\nA program can be concurrent but not parallel (single core with async I/O) or parallel but not concurrent (multiple cores doing independent work)."}
{"instruction": "How do I handle exceptions properly in Python?", "input": "", "output": "**Basic Exception Handling:**\n\n```python\ntry:\n    result = risky_operation()\nexcept ValueError as e:\n    print(f\"Invalid value: {e}\")\nexcept (TypeError, KeyError) as e:\n    print(f\"Type or key error: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n    raise  # Re-raise if you can't handle it\nelse:\n    print(\"Success!\")  # Runs if no exception\nfinally:\n    cleanup()  # Always runs\n```\n\n**Best Practices:**\n\n1. **Be specific:** Catch specific exceptions, not bare `except:`\n\n2. **Don't silence errors:** Either handle them or re-raise\n\n3. **Use context managers:** For resource cleanup\n   ```python\n   with open('file.txt') as f:\n       data = f.read()\n   ```\n\n4. **Create custom exceptions:**\n   ```python\n   class ValidationError(Exception):\n       def __init__(self, field, message):\n           self.field = field\n           super().__init__(f\"{field}: {message}\")\n   ```\n\n5. **Log exceptions:**\n   ```python\n   import logging\n   try:\n       operation()\n   except Exception:\n       logging.exception(\"Operation failed\")\n       raise\n   ```\n\n6. **Use `raise from` for exception chaining:**\n   ```python\n   except ValueError as e:\n       raise RuntimeError(\"Processing failed\") from e\n   ```"}
{"instruction": "Explain Docker containers and how they differ from virtual machines", "input": "", "output": "**Docker Containers:**\n- Lightweight, isolated environments for running applications\n- Share the host OS kernel\n- Package application + dependencies together\n- Start in seconds\n- Megabytes in size\n- Use less resources\n\n**Virtual Machines:**\n- Full operating system with dedicated kernel\n- Hardware virtualization via hypervisor\n- Complete isolation from host\n- Start in minutes\n- Gigabytes in size\n- More resource-intensive\n\n**Comparison:**\n\n| Aspect | Container | VM |\n|--------|-----------|----|\n| Boot time | Seconds | Minutes |\n| Size | MBs | GBs |\n| Performance | Near-native | Overhead |\n| Isolation | Process-level | Hardware-level |\n| OS | Shares host kernel | Full OS |\n| Portability | Very high | Limited |\n\n**Basic Docker Commands:**\n```bash\n# Run a container\ndocker run -d -p 8080:80 nginx\n\n# List containers\ndocker ps\n\n# Build an image\ndocker build -t myapp .\n\n# Stop container\ndocker stop container_id\n```\n\n**When to use:**\n- **Containers:** Microservices, CI/CD, consistent dev environments\n- **VMs:** Different OS requirements, strong isolation, legacy systems"}
{"instruction": "How do I optimize a slow SQL query?", "input": "", "output": "**Query Optimization Strategies:**\n\n**1. Use EXPLAIN/EXPLAIN ANALYZE:**\n```sql\nEXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';\n```\n\n**2. Add appropriate indexes:**\n```sql\n-- For frequently filtered columns\nCREATE INDEX idx_users_email ON users(email);\n\n-- Composite index for multi-column queries\nCREATE INDEX idx_orders_user_date ON orders(user_id, created_at);\n```\n\n**3. Avoid SELECT *:**\n```sql\n-- Bad\nSELECT * FROM users;\n\n-- Good\nSELECT id, name, email FROM users;\n```\n\n**4. Optimize JOINs:**\n- Ensure join columns are indexed\n- Use appropriate join types\n- Filter before joining when possible\n\n**5. Use LIMIT for large results:**\n```sql\nSELECT * FROM logs ORDER BY created_at DESC LIMIT 100;\n```\n\n**6. Avoid functions on indexed columns:**\n```sql\n-- Bad (can't use index)\nWHERE YEAR(created_at) = 2024\n\n-- Good\nWHERE created_at >= '2024-01-01' AND created_at < '2025-01-01'\n```\n\n**7. Consider query caching and materialized views**\n\n**8. Normalize or denormalize based on access patterns**\n\n**9. Use connection pooling**\n\n**10. Partition large tables**"}
{"instruction": "What is the CAP theorem?", "input": "", "output": "The CAP theorem states that a distributed system can only guarantee two of these three properties simultaneously:\n\n**C - Consistency:**\n- All nodes see the same data at the same time\n- Every read receives the most recent write\n- Like a single up-to-date copy of data\n\n**A - Availability:**\n- Every request receives a response (success or failure)\n- System remains operational\n- No request times out or returns an error\n\n**P - Partition Tolerance:**\n- System continues operating despite network failures\n- Messages between nodes can be lost or delayed\n- Required in distributed systems (network failures happen)\n\n**Practical Choices:**\n\n| Type | Properties | Examples | Trade-off |\n|------|------------|----------|------------|\n| CP | Consistency + Partition | MongoDB, HBase, Redis | May reject requests during partitions |\n| AP | Availability + Partition | Cassandra, DynamoDB, CouchDB | May return stale data |\n| CA | Consistency + Availability | Traditional RDBMS | Single node only, not distributed |\n\n**Reality:** Most systems choose partition tolerance (networks fail) and balance between consistency and availability based on requirements. Many offer tunable consistency levels."}
{"instruction": "How do I write a good README for my project?", "input": "", "output": "A good README should include:\n\n**1. Project Title & Description**\n```markdown\n# Project Name\n\nA brief, clear description of what the project does and why it exists.\n```\n\n**2. Badges (optional but helpful)**\n```markdown\n![Build Status](badge-url)\n![License](license-badge)\n```\n\n**3. Installation**\n```markdown\n## Installation\n\n```bash\npip install myproject\n# or\ngit clone https://github.com/user/project\ncd project\npip install -r requirements.txt\n```\n```\n\n**4. Quick Start / Usage**\n```markdown\n## Usage\n\n```python\nfrom myproject import Thing\n\nthing = Thing()\nresult = thing.do_something()\n```\n```\n\n**5. Configuration (if applicable)**\n\n**6. API Documentation or link to docs**\n\n**7. Examples**\n\n**8. Contributing guidelines**\n\n**9. License**\n\n**10. Credits/Acknowledgments**\n\n**Tips:**\n- Keep it concise but complete\n- Include screenshots/GIFs for visual projects\n- Update it as the project evolves\n- Write for someone who's never seen the project\n- Include troubleshooting for common issues"}
{"instruction": "Explain the SOLID principles in software design", "input": "", "output": "SOLID is a set of five design principles for maintainable, scalable code:\n\n**S - Single Responsibility Principle:**\nA class should have only one reason to change.\n```python\n# Bad: Class does too much\nclass User:\n    def save_to_db(self): ...\n    def send_email(self): ...\n    def generate_report(self): ...\n\n# Good: Separate responsibilities\nclass User: ...\nclass UserRepository: ...\nclass EmailService: ...\n```\n\n**O - Open/Closed Principle:**\nOpen for extension, closed for modification.\n```python\n# Use inheritance/composition instead of modifying existing code\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process(self, amount): ...\n\nclass CreditCardProcessor(PaymentProcessor): ...\nclass PayPalProcessor(PaymentProcessor): ...\n```\n\n**L - Liskov Substitution Principle:**\nSubtypes must be substitutable for their base types.\n```python\n# If Square extends Rectangle, it should work anywhere Rectangle works\n```\n\n**I - Interface Segregation Principle:**\nClients shouldn't depend on interfaces they don't use.\n```python\n# Bad: Fat interface\nclass Worker:\n    def work(self): ...\n    def eat(self): ...  # Robots don't eat\n\n# Good: Segregated interfaces\nclass Workable: ...\nclass Eatable: ...\n```\n\n**D - Dependency Inversion Principle:**\nDepend on abstractions, not concretions.\n```python\n# Inject dependencies via interfaces\ndef __init__(self, repository: Repository):  # Interface, not MySQLRepository\n```"}
{"instruction": "What are WebSockets and when should I use them?", "input": "", "output": "**WebSockets** provide full-duplex, bidirectional communication between client and server over a single persistent connection.\n\n**How it works:**\n1. Client initiates HTTP handshake with `Upgrade: websocket` header\n2. Server accepts, connection upgrades to WebSocket\n3. Both parties can send messages anytime\n4. Connection stays open until explicitly closed\n\n**vs HTTP:**\n\n| HTTP | WebSocket |\n|------|------------|\n| Request-response | Bidirectional |\n| New connection per request | Persistent connection |\n| Client initiates | Either party initiates |\n| Higher overhead | Lower overhead |\n\n**When to use WebSockets:**\n- Real-time applications (chat, gaming)\n- Live updates (stock prices, sports scores)\n- Collaborative tools (Google Docs-style)\n- Notifications\n- Live streaming data\n\n**When NOT to use:**\n- Simple request-response (use REST)\n- Infrequent updates (use polling or SSE)\n- When connection persistence isn't needed\n\n**Example (Python with FastAPI):**\n```python\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Received: {data}\")\n```\n\n**Alternatives:** Server-Sent Events (one-way), Long Polling, WebRTC (peer-to-peer)"}
{"instruction": "How do I secure a REST API?", "input": "", "output": "**Essential REST API Security Measures:**\n\n**1. Authentication:**\n```python\n# Use JWT tokens\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    user = verify_token(token)\n    if not user:\n        raise HTTPException(status_code=401)\n    return user\n```\n\n**2. HTTPS Everywhere:**\n- Encrypt all traffic\n- Never transmit tokens over HTTP\n\n**3. Input Validation:**\n```python\nfrom pydantic import BaseModel, validator\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str\n    \n    @validator('password')\n    def password_strength(cls, v):\n        if len(v) < 8:\n            raise ValueError('Password too short')\n        return v\n```\n\n**4. Rate Limiting:**\n- Prevent abuse and DDoS\n- Use tools like slowapi or Redis-based limiters\n\n**5. CORS Configuration:**\n```python\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"https://yourdomain.com\"],\n    allow_methods=[\"GET\", \"POST\"],\n)\n```\n\n**6. SQL Injection Prevention:**\n- Use parameterized queries/ORM\n- Never concatenate user input into queries\n\n**7. Security Headers:**\n- X-Content-Type-Options\n- X-Frame-Options\n- Content-Security-Policy\n\n**8. Audit Logging**\n\n**9. API Versioning**\n\n**10. Secrets Management** (environment variables, vaults)"}
